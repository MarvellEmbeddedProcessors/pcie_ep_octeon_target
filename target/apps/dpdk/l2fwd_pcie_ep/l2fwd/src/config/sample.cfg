/**
 * Objects and variables
 *
 * Variables
 * ----------
 * integer: idx: Index of pem/pf/vf
 * integer: [end_idx]: End index of pem/pf/vf
 *          If end index is specified, then configuration will be applied
 *          to [idx...end_idx-1]

 , mtu, hb_interval, hb_miss_count
 * string: to_host_dbdf, to_wire_dbdf = "xxxx:xx:x.x"
 * string: mac = "xx:xx:xx:xx:xx:xx"
 * bool autoneg, pause_mode = 0/1
 * long supported_modes, advertised_modes = 0...n
 * int pkind = 0/57/59
 *
 * Objects
 * -------
 * soc = { pem };
 * pem = { id, pf };
 * pf = { fn_base, [hb_interval], [hb_miss_count], [vf] };
 * vf = { fn_base };
 * fn_base = id, [pkind], [dbdfs], [if], [mac], [mtu], [autoneg], [pause_mode],
 *           [speed], [supported_modes], [advertised_modes]
 * dbdfs = ;
 * id = { idx, [end_idx] };
 *
 * Objects and variables shown in square brackets are optional
 * If vf[mac] is not specified, it will be derived from pf[mac]
 * vf[mac] will start from (pf[mac] + 1)
 * it will be auto incremented for each vf[idx:end_idx]
 */

soc = {
	/* 1 pem */
	pem = (
		{
			idx = 0;
			/* 1 pf */
			pf = (
				{
					idx = 0;
					autoneg = 0x3;
					pause_mode = 0x0;
					speed = 10000;
					supported_modes = 0x1;
					advertised_modes = 0x1;
					mtu = 1500;
					/* 8 vf's */
					vf = (
						{
							idx = 0;
							end_idx = 7;
							autoneg = 0x3;
							pause_mode = 0x3;
							speed = 10000;
							supported_modes = 0x1;
							advertised_modes = 0x1;
							mtu = 1500;
						}
					)
				}
			)
		}
	)
}
